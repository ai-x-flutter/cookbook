# レシピ#4-3: AIによるロジックと状態管理の実装

美しいUI（ユーザーインターフェース）はアプリの「顔」ですが、その裏でデータを処理し、状態を管理するロジックはアプリの「頭脳」です。このレシピでは、AIと協力して、この複雑な頭脳部分を効率的に実装する方法を学びます。

ここでのゴールは、**AIに状態管理の定型的なコードを書かせ、あなた自身はアプリケーションの本質的なロジックに集中する**ことです。

---

## 1. 状態管理の土台をAIに作らせる

状態管理ライブラリ（Riverpod, BLoCなど）の導入には、決まったお作法や定型的なコード（Boilerplate）がつきものです。この部分は、AIが最も得意とするところです。

### 例：Riverpodを使ったカウンターの状態管理

前のレシピでUIだけを作成したカウンターアプリに、Riverpodを使って状態を管理するロジックを追加させてみましょう。

> **🤖 AI活用プロンプト**
>
> あなたは、Riverpodを使った状態管理に非常に詳しいFlutterのエキスパートです。
>
> シンプルなカウンターアプリの状態管理ロジックを、**Riverpodの `NotifierProvider` と `Notifier` を使って**実装してください。
>
> **要件:**
> 1.  状態として、ひとつの整数（カウント数）を管理する。
> 2.  カウントを1増やす `increment()` メソッドを持つ。
> 3.  生成するコードは、`counter_provider.dart` というファイルに記述することを想定してください。
> 4.  コードには、各部分が何をしているのかを説明するコメントを追記してください。

**AIの応答（例）:**
```dart
// counter_provider.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

// 1. Notifierクラスの作成
// このクラスが、状態（state）と、それを変更するロジック（increment）を保持します。
class CounterNotifier extends Notifier<int> {
  // buildメソッドで状態の初期値を設定します。
  @override
  int build() {
    return 0; // カウンターの初期値は0
  }

  // 状態を変更するためのメソッド
  void increment() {
    state = state + 1; // 現在の状態（state）を更新する
  }
}

// 2. NotifierProviderの作成
// このProviderを介して、UI側からNotifierの機能にアクセスします。
final counterProvider = NotifierProvider<CounterNotifier, int>(() {
  return CounterNotifier();
});
```

**なぜこれが良いのか？**
*   **専門家ペルソナ:** 「Riverpodに詳しいエキスパート」と指定することで、ベストプラクティスに沿ったコードが生成されやすくなります。
*   **具体的な技術指定:** `NotifierProvider` と `Notifier` というキーワードを含めることで、AIはあなたがどのパターンの実装を望んでいるかを正確に理解します。
*   **定型コードの自動化:** このようなコードは、どのアプリでも似たような構造になります。AIに書かせることで、時間短縮とタイプミス防止に繋がります。

---

## 2. UIとロジックをAIに接続させる

状態管理のロジックが完成したら、次はUI側からそれを呼び出す「接続」部分のコードをAIに書かせます。

### 例：UIからカウンターロジックを呼び出す

> **🤖 AI活用プロンプト**
>
> ありがとう。完璧なProviderです。
>
> 次に、**この`counterProvider`を使って、カウンターアプリのUI部分を修正してください。**
>
> **元のUIコード:**
> ```dart
> // (ここに、以前UIだけを作った時のコードを貼り付ける)
> ```
>
> **要件:**
> 1.  `StatelessWidget` を `ConsumerWidget` に変更してください。
> 2.  `Text`ウィジェットで、`counterProvider`から現在のカウント数を取得して表示してください。
> 3.  `ElevatedButton`の`onPressed`で、`counterProvider`の`increment()`メソッドを呼び出してください。

**なぜこれが良いのか？**
*   **文脈の提供:** 「元のUIコード」をプロンプトに含めることで、AIはどのコードを修正すれば良いかを正確に把握します。
*   **明確な指示:** `ConsumerWidget`, `watch`, `read` といった、状態管理ライブラリ特有の「お作法」をAIが自動的に処理してくれます。あなたが細かいAPIを覚えていなくても問題ありません。

---

## 3. 複雑なビジネスロジックの壁打ち相手にする

AIは、より複雑なロジックの設計においても、優れた壁打ち相手になります。

### 例：TODOアプリのフィルタリングロジック

> **🤖 AI活用プロンプト**
>
> あなたはクリーンアーキテクチャに詳しいシニア開発者です。
>
> TODOアプリで、ユーザーが「すべて」「完了済み」「未完了」の3つのフィルタを切り替えられる機能を実装したい。
>
> 現在、`List<Todo>`の形で、すべてのTODOリストを状態として持っています。
> この状態と、現在のフィルターの状態（例: `enum FilterType { all, active, completed }`）を元に、**画面に表示すべきTODOリストを動的に計算するロジック**を考えてください。
>
> Riverpodの`Provider`を使い、他のProviderを組み合わせてこの派生状態（Derived State）を実現するための、効率的でクリーンなコードを提案してください。

**なぜこれが良いのか？**
*   **設計相談:** どのように実装すべきか分からない複雑な要件を、自然言語で相談できます。
*   **ベストプラクティスの提案:** AIは、あなたが知らないような、より効率的で洗練された実装パターン（この場合は`Provider`を組み合わせて派生状態を作る方法）を提案してくれることがあります。

このように、単純な作業の自動化から、複雑なロジ-ックの設計相談まで、AIはアプリケーションの「頭脳」を作るあらゆる段階で、あなたの強力なパートナーとなるのです。