# レシピ#4-9: AIのトークン消費を抑える実践テクニック

## 💡 まず知っておくべきこと：料金プランの選択肢

### Claude Proで使える機能

**Claude Pro（定額$20/月）で利用可能：**
- ✅ ターミナル（CLI）
- ✅ VS Code、Cursor、Windsurf
- ✅ Claude Code（GitHub連携版）
- ✅ 全機能が利用可能

参考: https://claude.ai/code/family

---

### 個人開発者の選択肢

**1. Claude Pro $20/月（定額プラン）**

✅ **こんな人におすすめ：**
- 毎日安定してコードを書く
- トークン消費を気にしたくない
- 月額固定費で予算管理したい

⚠️ **注意：**
- 使用量上限あり（一般的な個人開発には十分）
- 本格的に大量のコードを書く場合は上限に達する可能性

---

**2. Cursor Pro + Claude Pro の組み合わせ**

個人開発者に人気の組み合わせ：
- **Cursor Pro:** IDE機能とプレミアムリクエスト
- **Claude Pro:** Claude APIアクセス（定額）

両方合わせて月額$40程度で、快適な開発環境が整います。

---

**3. Claude MAX（上位プラン）**

✅ **こんな人に必要：**
- 本格的に大量のコードを書く
- Claude Proの上限では足りない
- プロフェッショナル開発者

---

**4. 従量課金（API直接利用）**

✅ **こんな人に適している：**
- 受託作業で日によってコード量が大きく変動する
- 使用量が不定期
- 細かいコスト管理が必要

💰 **料金：**
- Opus 4.5: $5/1M入力, $25/1M出力
- Sonnet 4.5: $3/1M入力, $15/1M出力

---

## 🎯 このガイドの位置づけ

**どのプランを使っていても、効率的なAIの使い方は重要です：**

- 適切なツール選択（Composer / Chat / Inline Edit）
- 無駄な往復を減らす
- トークン消費を抑える = 生産性向上

以下では、効率的なAI活用テクニックを学びます。

---

## 💰 従量課金を使う場合のコスト

### コストの現実

**Claude API料金（2025年12月時点）：**

| モデル | 入力トークン | 出力トークン |
|--------|------------|------------|
| **Opus 4.5** | $5/1M tokens | $25/1M tokens |
| **Sonnet 4.5** | $3/1M tokens | $15/1M tokens |

**例：** 10,000トークンのコンテキスト（約7,500ワード）で100回の対話：
- **Opus 4.5:** 約$30
- **Sonnet 4.5:** 約$18

**個人開発での月間コスト試算：**
- 毎日10回の対話 × 30日 = 月間300回
- **Opus 4.5のみ:** 約$90/月
- **Sonnet 4.5のみ:** 約$54/月
- **効率的な使い分け（Sonnet 80% / Opus 20%）:** 約$60/月

**効率的な使い方を知ることで、無駄なコストを抑えられます。**

---

## 🎯 トークン節約の基本原則

### 原則1: 必要最小限のコンテキストを渡す

**❌ 悪い例：**
```
Composer（Ctrl+I）で全プロジェクトを参照：
「アプリ全体を見て、ボタンの色を赤に変更してください」
→ 不要なファイルまで全て読み込まれる
```

**✅ 良い例：**
```
Inline Edit（Ctrl+K）で該当行を選択：
「このボタンを赤色にしてください」
→ 必要な部分だけを処理
```

**削減効果：** 90%以上のトークン節約

---

### 原則2: 適切なツールを選ぶ

| 機能 | トークン消費 | 使うべき場面 |
|------|------------|------------|
| **Inline Edit（Ctrl+K）** | ⭐ 最小 | 小さな修正・1箇所の変更 |
| **Chat（Ctrl+L）** | ⭐⭐ 小〜中 | 質問・相談・エラー調査 |
| **Composer（Ctrl+I）** | ⭐⭐⭐⭐⭐ 最大 | 複数ファイルの変更・新規ファイル作成 |

**基本ルール：**
- 小さな変更 → Inline Edit
- 質問・相談 → Chat
- 大規模な実装 → Composer

---

### 原則3: モデルを使い分ける

**Opus 4.5（高コスト）を使うべき場面：**
- 複雑なアーキテクチャ設計
- 大規模なリファクタリング
- 難しいバグの調査
- 初めての技術への挑戦

**Sonnet 4.5（低コスト）で十分な場面：**
- 簡単なUI実装
- 定型的なコード生成
- エラーメッセージの解読
- 小さな修正・調整

**削減効果：** 80%のコスト削減（同じ作業でも）

---

## 🛠️ 実践テクニック

### テクニック1: @マークを戦略的に使う

**❌ 無駄なコンテキスト：**
```
Composer（Ctrl+I）で：
「アプリ全体を見て、home_page.dartのボタンを修正してください」
→ プロジェクト全体が読み込まれる（数千〜数万トークン）
```

**✅ 必要なファイルだけ参照：**
```
Composer（Ctrl+I）で：
「@lib/home_page.dart を見て、ボタンを修正してください」
→ 1ファイルだけ読み込み（数百トークン）
```

**削減効果：** 90%以上のトークン節約

---

### テクニック2: 段階的に質問する

**❌ 一度に全てを聞く：**
```
Chat（Ctrl+L）で：
「Flutterの状態管理について、setState、Provider、Riverpod、BLoC、GetXの
違いを詳しく説明してください。それぞれのメリット・デメリット、使い分け、
サンプルコード、ベストプラクティス、アンチパターンも教えてください」
→ 膨大な回答（数千トークン）
```

**✅ 必要なことだけ聞く：**
```
Chat（Ctrl+L）で：
「FlutterでsetStateとProviderの違いを簡潔に教えてください」
→ 必要な情報だけ（数百トークン）
```

**削減効果：** 70〜80%のトークン節約

---

### テクニック3: プロンプトを具体的にする

**❌ 曖昧な指示（往復が増える）：**
```
Composer（Ctrl+I）で：
「TODOアプリを作ってください」

Claude: 「どのような機能が必要ですか？」
あなた: 「TODOの追加と削除」
Claude: 「データはどこに保存しますか？」
あなた: 「SharedPreferencesで」
→ 3往復（トークン3倍）
```

**✅ 具体的な指示（1回で完了）：**
```
Composer（Ctrl+I）で：
「TODOアプリを作ってください。機能：TODOの追加・削除・完了チェック。
データ保存：SharedPreferences。UI：Material Design。」

Claude: [実装を開始]
→ 1往復のみ
```

**削減効果：** 60〜70%のトークン節約

---

### テクニック4: 小さく実装して確認する

**❌ 大規模な実装を一度に依頼：**
```
Composer（Ctrl+I）で：
「TODOアプリを完全に実装してください。ホーム画面、詳細画面、設定画面、
データベース、API通信、認証、通知、テーマ切り替え、多言語対応も。」
→ 実装後に問題発覚 → 大規模な修正が必要（トークン大量消費）
```

**✅ 小さく作って確認：**
```
1. Composer（Ctrl+I）で：「TODOのホーム画面だけ作成」
   → 確認 → OK

2. Composer（Ctrl+I）で：「SharedPreferencesでの保存機能を追加」
   → 確認 → OK

3. Composer（Ctrl+I）で：「削除機能を追加」
   → 確認 → OK
```

**削減効果：** 失敗時の無駄なトークンを削減

---

### テクニック5: エラーは最小限の情報で相談

**❌ 全ての情報をコピペ：**
```
Chat（Ctrl+L）で：
[エラーログ全文をコピペ（500行）]
[該当ファイル全文をコピペ（300行）]
[pubspec.yaml全文をコピペ（100行）]
「このエラーを修正してください」
→ 900行のコンテキスト（数千トークン）
```

**✅ エラーの核心だけ送る：**
```
Chat（Ctrl+L）で：
「以下のエラーが出ました：
The method 'setState' isn't defined for the class 'MyWidget'

該当コード：
@lib/home_page.dart の50行目付近を見てください
」
→ 必要最小限（数百トークン）
```

**削減効果：** 80〜90%のトークン節約

---

### テクニック6: Chat履歴をリセットする

**Chatの履歴は累積する：**
```
1回目の質問: 100トークン
2回目の質問: 100 + 前回の履歴200トークン = 300トークン
3回目の質問: 100 + 前回の履歴500トークン = 600トークン
```

**新しいトピックは新しいChatで：**
- 無関係な話題は履歴をクリアしてから質問
- Cursor: Chat画面の「New Chat」ボタン
- または Ctrl+L で新しいChatを開始

**削減効果：** 50%以上のトークン節約（長い対話の場合）

---

## 📊 実践例：トークン消費の比較

### ケース1: ボタンの色を変更

**❌ 非効率な方法（約5,000トークン）：**
```
1. Composer（Ctrl+I）でプロジェクト全体を読み込み
2. 「ボタンの色を変更してください」
3. Claudeが全ファイルを解析
4. 変更を提案
```

**✅ 効率的な方法（約50トークン）：**
```
1. 該当行を選択
2. Inline Edit（Ctrl+K）で「このボタンを赤色にして」
3. 即座に変更
```

**削減率：** 99%

---

### ケース2: エラー修正

**❌ 非効率な方法（約8,000トークン）：**
```
1. Composer（Ctrl+I）で：
   「プロジェクト全体を見て、エラーを探して修正してください」
2. 全ファイルを解析
3. エラーを発見
4. 修正提案
```

**✅ 効率的な方法（約500トークン）：**
```
1. エラーログをコピー
2. Chat（Ctrl+L）で：
   「このエラーの原因を教えてください：
   [エラーメッセージ]」
3. 原因を理解
4. Inline Edit（Ctrl+K）で該当箇所を修正
```

**削減率：** 94%

---

### ケース3: 新しい画面の作成

**❌ 非効率な方法（約15,000トークン）：**
```
1. Composer（Ctrl+I）で全プロジェクトを読み込み
2. 曖昧な指示：「設定画面を作ってください」
3. Claudeが詳細を質問（往復3回）
4. 実装
```

**✅ 効率的な方法（約3,000トークン）：**
```
1. Composer（Ctrl+I）で：
   「@lib/main.dart を参照して、以下の設定画面を作成してください：
   - ファイル名: lib/screens/settings_page.dart
   - 機能: ダークモード切り替え、通知ON/OFF
   - データ保存: SharedPreferences」
2. 1回で実装完了
```

**削減率：** 80%

---

## 🎓 トークン節約のチェックリスト

### 実装前のチェック

- [ ] この作業にComposerは本当に必要か？（Inline EditやChatで済まないか？）
- [ ] 参照するファイルを@マークで明示的に指定したか？
- [ ] プロンプトは具体的か？（往復を減らせるか？）
- [ ] Sonnet 4.5で十分な作業か？（Opusが必要か？）

### 実装中のチェック

- [ ] 小さく実装して確認しているか？（大規模な失敗を避けられるか？）
- [ ] 不要なChat履歴を引きずっていないか？
- [ ] エラー情報は必要最小限か？（全文コピペしていないか？）

### 実装後のチェック

- [ ] 次回のために、効率的だった方法をメモしたか？
- [ ] 同じ質問を何度もしていないか？（よくある質問は記録しておく）

---

## 💡 モデル別の使い分け戦略

### Sonnet 4.5を使う場面（コスト効率重視）

**日常的な開発作業：**
- UI実装（ボタン、リスト、フォームなど）
- 定型的なコード生成（モデルクラス、APIクライアントなど）
- エラーメッセージの解読
- 簡単なリファクタリング
- コードレビュー
- ドキュメント作成

**コスト：** 約$3/100万入力トークン

---

### Opus 4.5を使う場面（品質重視）

**複雑な作業：**
- アーキテクチャ設計
- 複雑なバグの調査
- 大規模リファクタリング
- 新しい技術の導入
- パフォーマンス最適化
- セキュリティレビュー

**コスト：** 約$5/100万入力トークン

**戦略：**
- 全作業の80%をSonnet、20%をOpusにすることで、コストを効率化できる

---

## 🚀 実践的な節約ワークフロー

### ワークフロー1: 新機能の実装

```
1. 【Chat + Sonnet】設計を相談（低コスト）
   ↓
2. 【Composer + Sonnet】基本実装（中コスト）
   ↓
3. 【Inline Edit + Sonnet】細かい調整（超低コスト）
   ↓
4. 【Chat + Opus】複雑な問題の相談（必要時のみ）
```

**効率的なコスト管理が可能です。**

---

### ワークフロー2: バグ修正

```
1. エラーログを確認
   ↓
2. 【Chat + Sonnet】エラーの原因を質問（低コスト）
   ↓
3. 【Inline Edit + Sonnet】該当箇所を修正（超低コスト）
   ↓
4. （解決しない場合）【Chat + Opus】深い調査
```

**適切なツール選択で、無駄なトークン消費を避けられます。**

---

## 📈 トークン消費の可視化

### Cursorでの確認方法

**Cursor Settings > Usage > Token Usage**
- 今月の消費トークン数を確認
- モデル別の使用状況
- コスト推定

**定期的にチェックして、無駄な消費がないか確認しましょう。**

---

## ⚠️ やってはいけないこと

### ❌ アンチパターン1: 全てをComposerで処理

```
ボタンの色変更 → Composer（数千トークン）
変数名の変更 → Composer（数千トークン）
コメント追加 → Composer（数千トークン）
```

**正解：** 小さな変更はInline Edit（数十トークン）

---

### ❌ アンチパターン2: 常にOpusを使う

```
簡単なUI実装 → Opus（高コスト）
エラー解読 → Opus（高コスト）
ドキュメント作成 → Opus（高コスト）
```

**正解：** 日常作業はSonnet、複雑な作業だけOpus

---

### ❌ アンチパターン3: 曖昧な指示で何度も往復

```
「アプリを作って」
「どんな機能？」
「TODOアプリ」
「どこに保存？」
「SharedPreferences」
→ 3往復（トークン3倍）
```

**正解：** 最初から具体的に指示（1往復）

---

## 📝 まとめ

**トークン節約の3大原則：**

1. **適切なツールを選ぶ**
   - 小さな変更 → Inline Edit
   - 質問・相談 → Chat
   - 大規模実装 → Composer

2. **必要最小限のコンテキスト**
   - @マークで明示的に指定
   - エラーは核心だけ送る
   - Chat履歴をリセット

3. **モデルを使い分ける**
   - 日常作業 → Sonnet 4.5（80%）
   - 複雑な作業 → Opus 4.5（20%）

**これらのテクニックで、無駄なコストを抑えながら、生産性を最大化できます。**

効率的なAI活用は、開発スキルの一部です。賢く使って、コストと生産性の両方を最適化しましょう。

---

**次のステップ:** これらのテクニックを実際の開発で実践してみましょう。最初は意識的に、やがて自然にできるようになります。

➡️ **関連レシピ:**
- [`#4-1: Cursorを使った効率的な開発ワークフロー`](01_cursor_workflow.md)
- [`#1-2: AI開発ツールの導入`](../01_the_kitchen/02_ai_development_tools.md)
